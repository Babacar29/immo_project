-- =================================================================
-- SCHÉMA DE LA BASE DE DONNÉES POUR NOMAD'IMMO
-- =================================================================
-- Ce script contient les instructions SQL pour créer les tables
-- et configurer la sécurité pour votre application immobilière.
--
-- Instructions :
-- 1. Allez sur le tableau de bord de votre projet Supabase.
-- 2. Naviguez vers "SQL Editor".
-- 3. Cliquez sur "New query".
-- 4. Copiez et collez le contenu de ce fichier.
-- 5. Cliquez sur "RUN" pour exécuter les requêtes.
-- =================================================================


-- =================================================================
-- TABLE 1: PROFILES
-- Stocke les informations publiques des utilisateurs.
-- Se synchronise avec la table "auth.users" de Supabase.
-- =================================================================
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ,
  full_name TEXT,
  avatar_url TEXT,
  phone_number TEXT,
  email_from_auth TEXT,
  role TEXT DEFAULT 'user' NOT NULL -- ex: 'user', 'agent', 'admin'
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Rendez les politiques idempotentes pour pouvoir rejouer le script sans erreur
DROP POLICY IF EXISTS "Les profils sont visibles par tous." ON public.profiles;
DROP POLICY IF EXISTS "Les utilisateurs peuvent mettre à jour leur propre profil." ON public.profiles;

CREATE POLICY "Les profils sont visibles par tous."
ON public.profiles FOR SELECT
USING (true);

CREATE POLICY "Les utilisateurs peuvent mettre à jour leur propre profil."
ON public.profiles FOR UPDATE
USING (auth.uid() = id);

-- Trigger pour créer un profil lorsqu'un nouvel utilisateur s'inscrit
-- Ajoute la colonne email_from_auth si elle n'existe pas déjà
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS email_from_auth TEXT;
-- Ajoute/garantit la colonne created_at pour l'ordonnancement et l'historique
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ;
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'profiles' AND column_name = 'created_at'
  ) THEN
    ALTER TABLE public.profiles ALTER COLUMN created_at SET DEFAULT NOW();
    UPDATE public.profiles SET created_at = NOW() WHERE created_at IS NULL;
    ALTER TABLE public.profiles ALTER COLUMN created_at SET NOT NULL;
  END IF;
END $$;

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, avatar_url, email_from_auth)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'avatar_url',
    new.email
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Supprime le trigger s'il existe puis (re)crée-le pour éviter les erreurs sur re-exécution
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- =================================================================
-- TABLE 2: PROPERTIES
-- Stocke toutes les informations sur les biens immobiliers.
-- =================================================================
-- Rendez la création des types idempotente
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'property_type') THEN
    CREATE TYPE property_type AS ENUM ('villa', 'apartment', 'house', 'penthouse', 'riad', 'chalet');
  END IF;
END $$;

ALTER TYPE property_type ADD VALUE IF NOT EXISTS 'villa';
ALTER TYPE property_type ADD VALUE IF NOT EXISTS 'apartment';
ALTER TYPE property_type ADD VALUE IF NOT EXISTS 'house';
ALTER TYPE property_type ADD VALUE IF NOT EXISTS 'penthouse';
ALTER TYPE property_type ADD VALUE IF NOT EXISTS 'riad';
ALTER TYPE property_type ADD VALUE IF NOT EXISTS 'chalet';
ALTER TYPE property_type ADD VALUE IF NOT EXISTS 'agricultural_land';
ALTER TYPE property_type ADD VALUE IF NOT EXISTS 'industrial_land';

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'property_status') THEN
    CREATE TYPE property_status AS ENUM ('for_sale', 'for_rent', 'sold', 'rented', 'coming_soon');
  END IF;
END $$;

ALTER TYPE property_status ADD VALUE IF NOT EXISTS 'for_sale';
ALTER TYPE property_status ADD VALUE IF NOT EXISTS 'for_rent';
ALTER TYPE property_status ADD VALUE IF NOT EXISTS 'sold';
ALTER TYPE property_status ADD VALUE IF NOT EXISTS 'rented';
ALTER TYPE property_status ADD VALUE IF NOT EXISTS 'coming_soon';
ALTER TYPE property_status ADD VALUE IF NOT EXISTS 'off_plan';

CREATE TABLE IF NOT EXISTS public.properties (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  agent_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  description TEXT,
  location TEXT NOT NULL,
  address TEXT,
  latitude FLOAT,
  longitude FLOAT,
  price NUMERIC(12, 2) NOT NULL,
  bedrooms INT DEFAULT 0,
  bathrooms INT DEFAULT 0,
  area INT, -- en m²
  type property_type NOT NULL,
  status property_status DEFAULT 'for_sale' NOT NULL,
  is_featured BOOLEAN DEFAULT FALSE
);

ALTER TABLE public.properties ENABLE ROW LEVEL SECURITY;

-- Drop policies if they already exist to avoid duplicate errors
DROP POLICY IF EXISTS "Les propriétés sont visibles par tous." ON public.properties;
DROP POLICY IF EXISTS "Seuls les agents/admins peuvent insérer des propriétés." ON public.properties;
DROP POLICY IF EXISTS "Seuls les agents/admins peuvent modifier les propriétés." ON public.properties;
DROP POLICY IF EXISTS "Seuls les agents/admins peuvent supprimer des propriétés." ON public.properties;

CREATE POLICY "Les propriétés sont visibles par tous."
ON public.properties FOR SELECT
USING (true);

CREATE POLICY "Seuls les agents/admins peuvent insérer des propriétés."
ON public.properties FOR INSERT
WITH CHECK (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);

CREATE POLICY "Seuls les agents/admins peuvent modifier les propriétés."
ON public.properties FOR UPDATE
USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);

CREATE POLICY "Seuls les agents/admins peuvent supprimer des propriétés."
ON public.properties FOR DELETE
USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);


-- =================================================================
-- TABLE 3: PROPERTY_IMAGES
-- Stocke les URLs des images pour chaque propriété.
-- =================================================================
CREATE TABLE IF NOT EXISTS public.property_images (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  property_id BIGINT REFERENCES public.properties(id) ON DELETE CASCADE NOT NULL,
  image_url TEXT NOT NULL,
  alt_text TEXT,
  is_primary BOOLEAN DEFAULT FALSE
);

ALTER TABLE public.property_images ENABLE ROW LEVEL SECURITY;

-- Drop policies if they already exist to avoid duplicate errors
DROP POLICY IF EXISTS "Les images sont visibles par tous." ON public.property_images;
DROP POLICY IF EXISTS "Seuls les agents/admins peuvent ajouter des images." ON public.property_images;
DROP POLICY IF EXISTS "Seuls les agents/admins peuvent modifier les images." ON public.property_images;
DROP POLICY IF EXISTS "Seuls les agents/admins peuvent supprimer des images." ON public.property_images;

CREATE POLICY "Les images sont visibles par tous."
ON public.property_images FOR SELECT
USING (true);

CREATE POLICY "Seuls les agents/admins peuvent ajouter des images."
ON public.property_images FOR INSERT
WITH CHECK (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);

CREATE POLICY "Seuls les agents/admins peuvent modifier les images."
ON public.property_images FOR UPDATE
USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);

CREATE POLICY "Seuls les agents/admins peuvent supprimer des images."
ON public.property_images FOR DELETE
USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);


-- =================================================================
-- TABLE 4: FAVORITES
-- Suit les propriétés mises en favoris par les utilisateurs.
-- =================================================================
CREATE TABLE IF NOT EXISTS public.favorites (
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  property_id BIGINT REFERENCES public.properties(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  PRIMARY KEY (user_id, property_id)
);

ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;

-- Drop policies if they already exist to avoid duplicate errors
DROP POLICY IF EXISTS "Les utilisateurs peuvent voir leurs propres favoris." ON public.favorites;
DROP POLICY IF EXISTS "Les utilisateurs peuvent ajouter leurs favoris." ON public.favorites;
DROP POLICY IF EXISTS "Les utilisateurs peuvent supprimer leurs propres favoris." ON public.favorites;

CREATE POLICY "Les utilisateurs peuvent voir leurs propres favoris."
ON public.favorites FOR SELECT
USING (auth.uid() = user_id);

-- Supprime l'ancienne politique combinée si elle existe pour éviter les conflits
DROP POLICY IF EXISTS "Les utilisateurs peuvent ajouter/supprimer leurs propres favoris." ON public.favorites;

-- Politiques séparées pour gérer correctement INSERT (WITH CHECK) et DELETE sous RLS
CREATE POLICY "Les utilisateurs peuvent ajouter leurs favoris."
ON public.favorites FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Les utilisateurs peuvent supprimer leurs propres favoris."
ON public.favorites FOR DELETE
USING (auth.uid() = user_id);


-- =================================================================
-- TABLE 5: VISITS
-- Gère les demandes de visite pour les propriétés.
-- =================================================================
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'visit_status') THEN
    CREATE TYPE visit_status AS ENUM ('pending', 'confirmed', 'cancelled', 'completed');
  END IF;
END $$;

ALTER TYPE visit_status ADD VALUE IF NOT EXISTS 'pending';
ALTER TYPE visit_status ADD VALUE IF NOT EXISTS 'confirmed';
ALTER TYPE visit_status ADD VALUE IF NOT EXISTS 'cancelled';
ALTER TYPE visit_status ADD VALUE IF NOT EXISTS 'completed';

CREATE TABLE IF NOT EXISTS public.visits (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  property_id BIGINT REFERENCES public.properties(id) ON DELETE CASCADE,
  agent_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  visit_date TIMESTAMPTZ NOT NULL,
  message TEXT,
  status visit_status DEFAULT 'pending' NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

ALTER TABLE public.visits ENABLE ROW LEVEL SECURITY;

-- Ajoute une contrainte de clé étrangère vers profiles pour permettre l'embed PostgREST
ALTER TABLE public.visits DROP CONSTRAINT IF EXISTS visits_user_id_profiles_fkey;
ALTER TABLE public.visits
  ADD CONSTRAINT visits_user_id_profiles_fkey
  FOREIGN KEY (user_id)
  REFERENCES public.profiles(id)
  ON DELETE CASCADE;

-- Drop policies if they already exist to avoid duplicate errors
DROP POLICY IF EXISTS "Les utilisateurs peuvent voir leurs propres demandes de visite." ON public.visits;
DROP POLICY IF EXISTS "Les utilisateurs peuvent créer des demandes de visite." ON public.visits;
DROP POLICY IF EXISTS "Les utilisateurs peuvent annuler leurs propres visites (si 'pending')." ON public.visits;
DROP POLICY IF EXISTS "Les agents/admins peuvent voir toutes les visites." ON public.visits;
DROP POLICY IF EXISTS "Les agents/admins peuvent mettre à jour le statut des visites." ON public.visits;

CREATE POLICY "Les utilisateurs peuvent voir leurs propres demandes de visite."
ON public.visits FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Les utilisateurs peuvent créer des demandes de visite."
ON public.visits FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Les utilisateurs peuvent annuler leurs propres visites (si 'pending')."
ON public.visits FOR UPDATE
USING (auth.uid() = user_id AND status = 'pending');

CREATE POLICY "Les agents/admins peuvent voir toutes les visites."
ON public.visits FOR SELECT
USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);

CREATE POLICY "Les agents/admins peuvent mettre à jour le statut des visites."
ON public.visits FOR UPDATE
USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);


-- =================================================================
-- TABLE 6: SALES
-- Historique des ventes de propriétés.
-- =================================================================
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'sales_status') THEN
    CREATE TYPE sales_status AS ENUM ('pending', 'completed', 'cancelled');
  END IF;
END $$;

ALTER TYPE sales_status ADD VALUE IF NOT EXISTS 'pending';
ALTER TYPE sales_status ADD VALUE IF NOT EXISTS 'completed';
ALTER TYPE sales_status ADD VALUE IF NOT EXISTS 'cancelled';

CREATE TABLE IF NOT EXISTS public.sales (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  property_id BIGINT REFERENCES public.properties(id) ON DELETE CASCADE NOT NULL,
  buyer_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  sale_price NUMERIC(12, 2) NOT NULL,
  sale_date TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  status sales_status DEFAULT 'completed' NOT NULL
);

ALTER TABLE public.sales ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if any to avoid duplicates
DROP POLICY IF EXISTS "Les agents/admins peuvent voir toutes les ventes." ON public.sales;
DROP POLICY IF EXISTS "Les agents/admins peuvent ajouter des ventes." ON public.sales;
DROP POLICY IF EXISTS "Les agents/admins peuvent modifier les ventes." ON public.sales;
DROP POLICY IF EXISTS "Les agents/admins peuvent supprimer des ventes." ON public.sales;

CREATE POLICY "Les agents/admins peuvent voir toutes les ventes."
ON public.sales FOR SELECT
USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);

CREATE POLICY "Les agents/admins peuvent ajouter des ventes."
ON public.sales FOR INSERT
WITH CHECK (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);

CREATE POLICY "Les agents/admins peuvent modifier les ventes."
ON public.sales FOR UPDATE
USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);

CREATE POLICY "Les agents/admins peuvent supprimer des ventes."
ON public.sales FOR DELETE
USING (
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);

-- Make sure buyer_id is nullable for cases where buyer is not specified
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' AND table_name = 'sales' AND column_name = 'buyer_id' AND is_nullable = 'NO'
  ) THEN
    ALTER TABLE public.sales ALTER COLUMN buyer_id DROP NOT NULL;
  END IF;
END $$;

-- Trigger: lorsqu'une vente est marquée complétée, passer la propriété à "sold"
CREATE OR REPLACE FUNCTION public.set_property_sold_on_sale()
RETURNS TRIGGER AS $$
BEGIN
  -- For inserts/updates, manage property status according to sale status
  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    IF NEW.status = 'completed' THEN
      UPDATE public.properties
      SET status = 'sold'
      WHERE id = NEW.property_id;
    ELSE
      -- If sale moved away from completed, and there is no other completed sale for this property, revert status
      IF NOT EXISTS (
        SELECT 1 FROM public.sales s
        WHERE s.property_id = NEW.property_id AND s.status = 'completed'
      ) THEN
        UPDATE public.properties
        SET status = 'for_sale'
        WHERE id = NEW.property_id AND status = 'sold';
      END IF;
    END IF;
  END IF;
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trg_set_property_sold_on_sale ON public.sales;
CREATE TRIGGER trg_set_property_sold_on_sale
  AFTER INSERT OR UPDATE ON public.sales
  FOR EACH ROW
  EXECUTE PROCEDURE public.set_property_sold_on_sale();

-- Handle deletion of sales: if a completed sale is removed and no other completed sales remain, revert property status
CREATE OR REPLACE FUNCTION public.revert_property_on_sale_delete()
RETURNS TRIGGER AS $$
BEGIN
  IF OLD.status = 'completed' THEN
    IF NOT EXISTS (
      SELECT 1 FROM public.sales s
      WHERE s.property_id = OLD.property_id AND s.status = 'completed'
    ) THEN
      UPDATE public.properties
      SET status = 'for_sale'
      WHERE id = OLD.property_id AND status = 'sold';
    END IF;
  END IF;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trg_revert_property_on_sale_delete ON public.sales;
CREATE TRIGGER trg_revert_property_on_sale_delete
  AFTER DELETE ON public.sales
  FOR EACH ROW
  EXECUTE PROCEDURE public.revert_property_on_sale_delete();


-- =================================================================
-- TABLE 7: CONVERSATIONS (pour le chat)
-- Permet d'identifier un fil de discussion par UUID (stocké côté client).
-- =================================================================
CREATE TABLE IF NOT EXISTS public.conversations (
  id UUID PRIMARY KEY,
  guest_identifier TEXT,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Ajouter la colonne user_id si elle n'existe pas
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' AND table_name = 'conversations' AND column_name = 'user_id'
  ) THEN
    ALTER TABLE public.conversations ADD COLUMN user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;
  END IF;
END $$;

ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;

-- Politiques idempotentes
DROP POLICY IF EXISTS "Conversations: insert pour tous" ON public.conversations;
DROP POLICY IF EXISTS "Conversations: update pour tous" ON public.conversations;
DROP POLICY IF EXISTS "Conversations: select pour admins" ON public.conversations;
DROP POLICY IF EXISTS "Conversations: select pour tous" ON public.conversations;

-- Autoriser la création/upsert de conversations pour tout le monde (utilisateurs connectés ou invités)
CREATE POLICY "Conversations: insert pour tous"
ON public.conversations FOR INSERT
WITH CHECK (true);

-- Autoriser l'update pour supporter l'UPSERT côté client
CREATE POLICY "Conversations: update pour tous"
ON public.conversations FOR UPDATE
USING (true)
WITH CHECK (true);

-- Lecture autorisée pour tous : anonymes, utilisateurs connectés et admins
CREATE POLICY "Conversations: select pour tous"
ON public.conversations FOR SELECT
USING (true);


-- =================================================================
-- TABLE 8: MESSAGES (pour le chat)
-- Les messages d'un fil de discussion. Realtime doit être activé sur cette table.
-- =================================================================
CREATE TABLE IF NOT EXISTS public.messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  conversation_id UUID REFERENCES public.conversations(id) ON DELETE CASCADE NOT NULL,
  content TEXT NOT NULL,
  sender_id UUID NULL,            -- null pour les invités
  sender_role TEXT NOT NULL       -- 'guest' | 'user' | 'admin'
);

CREATE INDEX IF NOT EXISTS idx_messages_conversation_id ON public.messages(conversation_id);

ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Politiques idempotentes
DROP POLICY IF EXISTS "Messages: lire pour tous" ON public.messages;
DROP POLICY IF EXISTS "Messages: écrire pour tous" ON public.messages;
DROP POLICY IF EXISTS "Messages: update par admins" ON public.messages;
DROP POLICY IF EXISTS "Messages: delete par admins" ON public.messages;

-- Pour le widget public, permettre la lecture de tous les messages (le client filtre par conversation_id)
CREATE POLICY "Messages: lire pour tous"
ON public.messages FOR SELECT
USING (true);

-- Permettre à tous (invités et utilisateurs) d'envoyer des messages
CREATE POLICY "Messages: écrire pour tous"
ON public.messages FOR INSERT
WITH CHECK (true);

-- Gestion via back-office uniquement
CREATE POLICY "Messages: update par admins"
ON public.messages FOR UPDATE
USING (
  auth.role() = 'authenticated' AND 
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
)
WITH CHECK (
  auth.role() = 'authenticated' AND 
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);

CREATE POLICY "Messages: delete par admins"
ON public.messages FOR DELETE
USING (
  auth.role() = 'authenticated' AND 
  (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('agent', 'admin')
);